{"name":"Ms. pacman vs ghost team","tagline":"","body":"This code is an implementation of \"Ms Pac-Man\" for the \"Ms Pac-Man vs Ghosts Competition\".\r\nThis competition is organised by Philipp Rohlfshagen, David Robles and Simon Lucas of the University \r\nof Essex.\r\n\r\nThe code is written by Philipp Rohlfshagen based on earlier implementations of the game by Simon Lucas \r\nand David Robles.\r\n\r\nCompetition website: www.pacman-vs-ghosts.net\r\n\r\nCompetition organisers: Philipp Rohlfshagen, David Robles and Simon Lucas (University of Essex)\r\n\r\n# **Quick Starter Guide**\r\n\r\n## Run software\r\n\r\n1. **Download:**\r\nDownload the software and unzip it in a convenient location on your computer.\r\n2. **Create a Project:**\r\nOpen Eclipse and create a new (empty) Java project.\r\n3. **Import files:**\r\n   1. Click on File, then Import ... and choose General, then File System.\r\n   2. In the 'From directory' dialog, choose the folder where you unzipped the software.\r\n   3. In the 'Into folder' dialog, choose the project you just created.\r\n4. **Click Finished.**\r\n4. **Run the Code**\r\n\r\nYou can execute the code by running the class\r\n`Executor.java`\r\nThis class contains a main method with numerous options for execution. Just uncomment the one you wish to run.\r\n\r\n## Start coding\r\n1. **Inspect the Files** \r\n  The files you need to edit are: \r\n 1. pacman.entries.pacman.MyPacMan.java \r\n 2. pacman.entries.ghosts.MyGhosts.java \r\n\r\n  These files extend `Controller.java`. You will need to provide code for the `getMove(Game game, long timeDue)` method. \r\n \r\n2. **The `getMove()` Method** \r\n\r\n In order to create a controller, you need to provide code for the method:\r\n `getMove(Game game, long timeDue)` \r\n in MyPacMan.java or MyGhosts.java. These files are already included in the code. \r\n\r\n In the case of Ms Pac-Man, this method returns an element of the MOVE enumeration found in Constants.java. The elements are: \r\n * `MOVE.UP` \r\n * `MOVE.RIGHT` \r\n * `MOVE.DOWN` \r\n * `MOVE.LEFT` \r\n * `MOVE.NEUTRAL` \r\n\r\n In the case of the ghosts, this method returns an `EnumMap` that maps every element from the enumeration `GHOST` to `MOVE`: \r\n\r\n * `GHOST.BLINKY` \r\n * `GHOST.PINKY` \r\n * `GHOST.INKY` \r\n * `GHOST.SUE` \r\n\r\n To calculate a good move, you can query the game object to access information about the game state. The long timeDue indicates the system time the next move is due. You have 40ms per game tick to provide a response. \r\n\r\n3. **The Game object**\r\nEvery game tick, your controller receives a copy of the current game state via the `getMove()` method. The game object contains all the information required to make an informed decision. The class Game.java is the only class you need to be concerned with (you may also need to know about Constants.java, which holds all the game's enumerations and constants, and GameView in case you would like to use visual aids. The game is represented as a graph: you move from one node to another throughout the game. Pills and powerpills are located on specific nodes throughout the maze. Nodes are generally referred to by their indices.\r\n\r\n4. **Putting it together**\r\nWhenever the `getMove(-)` method gets called, you receive a new copy of the game and the time the move is due. Query the game state using its many methods to obtain information about the pills, powerpills, positions of Pac-Man and the Ghosts etc. The game also provides numerous additional helper methods to obtains things like shortest paths or moves to take to approach a specific target. \r\n\r\n# Tutorials\r\n## Timings\r\n\r\nThe game is played asynchronously in real time: every discrete game tick, the game uses the moves supplied by the controllers to update the gamestate. Then, the game waits for 40ms for new actions to come in, after which the game updates again. At each game tick, the controllers have 40 ms to respond. The controllers are given a copy of the current game and the time the move is due. Each controller can then query the game using its many methods to compute an appropriate response. It is the responsibility of the controller to respond in a timely manner (this is one of the challenges of the competition). \r\n\r\nIf a controller returns a move on time, the game will use that move to advance the game. If the move happens to be illegal, the game tries to replay the previous move or chooses a new legal move randomly. If a controller does not replay on time, the game tries to play the previous move or, if that is not possible, chooses a legal move randomly. \r\n\r\nThe controller will receive a new copy of the game state for the remaining time of that game tick to compute a new move. In other words, if a controller takes 60ms to respond, it will have roughly (2x40)-60=20ms in the next game tick. If a controller does not reply over several game ticks, the game keeps replaying previous actions.\r\n\r\n##Software\r\n\r\nThe `Executor` runs a game by instantiating two controllers (one for Ms. Pac-Man, one for the Ghosts) and creating a new game\r\nobject. It then supplies each controller with a copy of the game object and then waits for 40ms for each controllers to compute their\r\naction. After the time is up, the actions computed by the controllers are used to advance the game state. This is continued until the\r\nend of the game (or the limit has been reached).\r\n\r\nEach controller extends the abstract class Controller. The only method that needs implementation is \r\n\r\n`getMove(Game game, long timeDue)` \r\n\r\nThe game object is a copy of the current game state and timeDue signals the point in time the game advances; a controller should\r\nreturn an action before the time is up. Your code must be in either\r\n \r\n  pacman.entries.pacman.MyPacMan.java \r\n  pacman.entries.ghosts.MyGhosts.java\r\n \r\nproviding an implementation of the `getMove(-)` method. These files are already included in the software.\r\n\r\nThe controllers can access all the information about the game by using the many methods provided in Game. In fact, game is almost the only class you need to worry about. The only other two classes are \r\n\r\n * **Constants.java**: this class contains the constants of the game and its enumerations.\r\n * **GameView.java**: it is possible to use certain visual features to help you develop your controllers. \r\n\r\nThe moves of the game are implemented as an enumeration. The options are: \r\n * `MOVE.UP` \r\n * `MOVE.RIGHT` \r\n * `MOVE.DOWN` \r\n * `MOVE.LEFT` \r\n * `MOVE.NEUTRAL` \r\n\r\nMs. Pac-Man controllers need to return one of these moves at every time step. Ms Pac-Man returns a single MOVE every time\r\nstep. If the controller returns null or an illegal move (e.g., trying to go up even though there is a wall), the game engine will try to play the last move if possible or else choose a legal move randomly. \r\n\r\nThe ghosts controller needs to return one move for each of the 4 ghosts. The ghosts are encoded using another enumeration called\r\nGHOST:\r\n\r\n * `GHOST.BLINKY` \r\n * `GHOST.PINKY` \r\n * `GHOST.INKY` \r\n * `GHOST.SUE` \r\n\r\nThe reply from a ghosts controller is an EnumMap that maps from each type of ghost to a move. For instance, the following shows\r\nhow to return a left move for Blinky: \r\n\r\n`EnumMap<GHOST, MOVE> myMoves = new EnumMap<GHOST, MOVE>(GHOST.class)` \r\n\r\n`myMoves.put(GHOST.BLINKY, MOVE.LEFT);` \r\n\r\nA ghost controller can return moves for 0 or more ghosts. Any missing moves will be substituted by the game engine (including the\r\ncase where the controller returns null). \r\n\r\nOnce the time is up, the game will advance using the moves computed by the controllers. If no move was returned, the game engine\r\ntries to repeat the previous move played or chooses a legal move uniformly at random. If a controller returns a move after the time\r\nlimit is up, the controller will be given the remaining time in the current time step to compute a new move. \r\n\r\nTo make an informed decision, the controllers may query the game state to obtains all relevant information. This is done via the\r\nmany methods provided (see tutorial on Game.java). The game consists of 4 mazes that are encountered in succession. Each\r\nmaze is modelled as a graph: Ms Pac-Man and each of the ghosts move from node to node along this graph. Pills and powerpills\r\nare also located on nodes. Each node has a set of neighbours that may be reached: in a corridor, for instance, a node has two\r\nneighbours, at junctions 3 or 4 neighbours. The only exception to this is the lair (where the ghosts start and return to once eaten)\r\nwhich does not have any neighbours at all.\r\n\r\nOne of the most useful information is the distance between any two nodes in the maze. For reasons of efficiency, the shortest path\r\ndistances from any node to any other node have been precomputed (using Dijstra) and are loaded from file when the game starts.\r\nThe shortest path distances may be used for Ms Pac-Man to determine the distance between selected nodes. However, since\r\nghosts are not allowed to reverse, distances may be longer (as a ghost may be forced to take a longer route to avoid reversal).\r\nThere are two ways to get the shortest path distance for a ghost: \r\n\r\n * **Approximate**: uses the shortest path distances to greedily construct the path the ghost would have to take. This accounts for\r\nthe fact that reversals are not allowed but may sometimes lead to an incorrect path (we found the error to be very minor).\r\n * **Exact**: this uses A* to compute the actual shortest path. This is more costly than the approximate version but still efficient. The admissable heuristic used is the actual shortest path distances so very few nodes get expanded on average. \r\n\r\nBelow is a list of all the classes: \r\n\r\n * **Game.java**: the game engine and all the methods required to access the game state.\r\n * **Pacman.java**: datastructure used by the game to hold the information about Ms Pac-Man\r\n * **Ghost.java**: datastructure used by the game to hold the information about the ghosts\r\n * **Maze.java**: each level is an instance of a maze, a fixed and immutable data structure that stores the location of all the nodes\r\nin the graph that makes up each level\r\n * **Node.java**: a node in the graph\r\n * **AStar.java**: a class to compute shortest paths for the ghosts from any node to any other using A* and the pre-computed\r\nshortest path distances\r\n * **Constants.java**: includes the enumerations and constants of the game.\r\n * **GameView.java**: this draws the game to the screen. There are some features here you may use to highlight nodes, paths,\r\netc. Have a look here for more information.\r\n * **GameView.java**: this draws the game to the screen. There are some features here you may use to highlight nodes, paths,\r\netc. Have a look here for more information.\r\n * **Controller.java**: the superclass every controller must implement. Provides the threading and an empty getMove(-) method the\r\ncontrollers must implement.\r\n * **HumanController.java**: a simple class to allow humans to play the game using the arrow keys of the keyboard.\r\n * **KeyBoardInput.java**: a simple helper class to capture keyboard events for the human controller.\r\n * **Executor.java**: the class used to run the games in various different modes (more information below).\r\n\r\nThe other files contains in pacman.controllers.examples are example controllers that serve as examples and which you may use to test and evaluate your own code.\r\n\r\nThe class Executor contains a main method and a choice of static methods which contain the different modes of operation. You can execute the game in 3 ways: \r\n\r\n * **synchronous**: the game waits until both controllers have computed an action. This can be very fast if both controller reply\r\nquickly or take a very long time if the controllers require a long time to compute the next move to make.\r\n * **asynchronous**: this is the mode used for the comeptition. The game gives each controller 40ms of system time to compute a\r\nmove. After the time is up, the game advances. If a controller is unable to supply an action in time, the controller's previous\r\naction is repeated (if possible) or a legal action is chosen uniformly at random.\r\n * **asynchronous (time optimised)**: this mode is identical to the one above but if both controllers reply before the time limit is up, the game advances immediately. \r\n\r\n##Visuals\r\n\r\nThe methods for adding visuals to the game view are all static member of `GameView`. All the methods required to add visuals are static so can be called without having to have an instance of `GameView`. You can do\r\ntwo things: \r\n\r\n * add highlights to nodes (takes the game object, the colour to be used and the node indices to be highlighted). \r\n * add lines from any node to any other node (takes the game object, a colour and either a single pair of indices or an array of matched indices) \r\n\r\nAny highlights added to the game view are active for a single game tick only so you need to add them at every game tick (in your\r\ngetMove(-) method). \r\n\r\nBelow is an example that highlights the path from the current location of Ms Pac-Man to the nearest power pill:\r\n\r\n`GameView.addPoints(game,Color.CYAN,game.getShortestPath(game.getPacmanCurrentNodeIndex(),nearestActivePowerPillIndex))`\r\n\r\nwhere nearestActivePowerPillIndex is the index of the nearest power pill that has not yet been eaten. \r\n\r\nThe code snippet below draws a line from the current position of Ms Pac-Man to all remaining power pills: \r\n\r\n```\r\nint[] activePowerPills=game.getActivePowerPillsIndices();\r\n\r\nfor(int i=0;i<activePowerPills.length;i++)\r\n  GameView.addLines(game,Color.CYAN,game.getPacmanCurrentNodeIndex(),activePowerPills[i]);\r\n```\r\n\r\n#Rules of the game\r\n\r\n##General rules\r\n\r\nThe game consists of four mazes (A, B, C and D), which are played in order; when maze D is cleared (i.e., all pills have been eaten by Ms Pac-Man), the game continues with maze A and so on until the game is over. Each maze contains a different layout with pills and power pills placed at specific locations. Ms Pac-Man starts the game with three lives; an additional life is awarded at 10,000 points. \r\n\r\nThe goal of Ms Pac-Man is to obtain the highest possible score by eating all the pills and power pills in the maze (and thus advancing to the next stage). Each pill eaten scores 10 points, each power pill is worth 50 points. Ms Pac-Man's quest is opposed by the four ghosts: Blinky (red), Pinky (pink), Inky (green) and Sue (brown). At the start of each level, the ghosts start in the lair in the middle of the maze and, after some idle time, enter the maze in their pursuit of Ms Pac-Man. Their goal is to eat Ms Pac-Man and each time this happens, a life is lost and Ms Pac-Man and the ghosts return to their initial positions; the time spent by the ghosts in the lair decreases as the player progresses to higher levels. \r\n\r\nThere are four power pills in each of the four mazes, which, when eaten, reverse the direction of the ghosts and turn them blue; they may now be eaten for extra points. The score for eating each ghost in succession immediately after a power pill has been consumed starts at 200 points and doubles each time, for a total of 200+400+800+1600=3000 additional points. Any ghost that has been eaten re-appears in the lair and emerges soon after, once again chasing Ms Pac-Man. If a second power pill is consumed while some ghosts remain edible, the ghost score is reset to 200; if the level is cleared while the ghosts remain edible, play continuous immediately to the next level. \r\n\r\nThe more advanced the level, the shorter the ghost edible times become, making the levels progressively more difficult; at an advanced stage, the ghosts do not turn blue at all (however, they still change direction). When the edible period runs out, the ghosts start flashing blue and white. The player (or agent) needs to be careful at this stage to avoid losing lives. When all the pills and power pills have been cleared, the game moves on to the next maze. \r\n\r\n##Goals\r\n\r\nThe goal of a Ms Pac-Man controller is to maximise the score of the game. In the competition, it is the average score against multiple ghost teams that counts and the winning controller is the one which obtains the highest total average score. \r\n\r\nThe goal of a ghost-team controller is to minimise the average score obtained agains t it by the different Ms Pac-Man controllers. The winning ghost team will be team with the lowest average score against it. \r\n\r\n##Deviations from the Original\r\n\r\nA few changes were made to simplify the game. \r\n\r\n 1. The speed of Ms Pac-Man and the ghosts are always identical, except when ghosts are edible (in which case the ghosts reduce their speed by half). \r\n 2. Bonus fruits are omitted. \r\n 3. Each maze is played once before moving on to the next one (in the original, each maze was played twice in succession). \r\n\r\n##Ghost-Team-Specific Rules\r\n\r\nThere are no restrictions regarding the actions of Ms Pac-Man: movement in any direction not blocked by a wall is allowed at all times. For the ghost team, on the other hand, three restrictions apply: \r\n\r\n 1. Ghosts may not reverse direction. Subsequently, a ghost may only choose its direction at a junction, choosing any of the paths available except the one the ghost used to approach the junction. \r\n 2. Occasionally there is a global reversal event when all the ghosts suddenly change direction. This may happen in any game tick with a small probability of 0.0015. \r\n 3. To prevent the ghosts from spoiling the game by constantly blocking the power pills (in which case the game would result in a stalemate), each level finishes after 3000 time steps; half the score of all remaining pills are awarded to Ms Pac-Man. \r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}